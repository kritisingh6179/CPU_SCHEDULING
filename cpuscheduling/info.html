<!doctype html>
<html lang="en">

<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
  <link rel="stylesheet" href="info.css">
  <title>DETAILED INFORMATION</title>


</head>

<body>
  <div>
    <nav class="navbar navbar-expand-lg navbar-light fixed-top py-1" id="mainNav">
      <div class="container">
        <a class="navbar-brand js-scroll-trigger" href="#"><i class="fa fa-files-o" aria-hidden="true"></i> CPU
          SCHEDULING ALGORITHM DETAIL INFORMATION </a>
        <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
          data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
          aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
        <div class="collapse navbar-collapse" id="navbarResponsive">
          <ul class="navbar-nav ml-auto my-2 my-lg-0">
            <li class="nav-item"><a class="nav-link" href="1.html">Home</a></li>


          </ul>

        </div>
      </div>
    </nav>
    <br>
    <br>

  </div>

  <div class="srtf_info a" id="x8">
    <center>
      <div>
        <h1>Shortest Remaining Time First (SRTF) algorithm</h1> </center>
      </div>
   
    <hr>

    <div>
      This Algorithm is the preemptive version of SJF scheduling. In SRTF, the execution of the process can be stopped
      after certain amount of time. At the arrival of every process, the short term scheduler schedules the process with
      the least remaining burst time among the list of available processes and the running process.

      Once all the processes are available in the ready queue, No preemption will be done and the algorithm will work as
      SJF scheduling. The context of the process is saved in the Process Control Block when the process is removed from
      the execution and the next process is scheduled. This PCB is accessed on the next execution of this process.
    </div>
    <br>
    <div>
      <h2>Advantages</h2>
      <li>SRTF algorithm makes the processing of the jobs faster than SJF algorithm, given it’s overhead charges are not
        counted.</li>

    </div>
    <br>
    <div>
      <h2>Disadvantages</h2>
      <li>The context switch is done a lot more times in SRTF than in SJF, and consumes CPU’s valuable time for
        processing. This adds up to it’s processing time and diminishes it’s advantage of fast processing.</li>

    </div>

    <div>
      <br>
      <h2>Example</h2>
      <p>Consider the following table of arrival time and burst time for four processes P1, P2, P3, P4, P5 and P6.</p>
      <table border="2px">
        <thead>
          <tr>
            <th>Process Name</th>
            <th>Arrival Time</th>
            <th>Burst time</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <th>P1</th>
            <th>0</th>
            <th>8</th>
          </tr>
          <tr>
            <th>P2</th>
            <th>1</th>
            <th>4</th>
          </tr>
          <tr>
            <th>P3</th>
            <th>2</th>
            <th>2</th>
          </tr>
          <tr>
            <th>P4</th>
            <th>3</th>
            <th>1</th>
          </tr>
          <tr>
            <th>P5</th>
            <th>4</th>
            <th>3</th>
          </tr>
          <tr>
            <th>P6</th>
            <th>5</th>
            <th>2</th>
          </tr>

        </tbody>
      </table>
      <br>
      <h2>Working</h2>
      <p>
        1. at time 0, the only available process is P1 with CPU burst time 8. This is the only available process in the
        list therefore it is scheduled.<br>
        2. The next process arrives at time unit 1. Since the algorithm we are using is SRTF which is a preemptive one,
        the current execution is stopped and the scheduler checks for the process with the least burst time.
        Till now, there are two processes available in the ready queue. The OS has executed P1 for one unit of time till
        now; the remaining burst time of P1 is 7 units. The burst time of Process P2 is 4 units. Hence Process P2 is
        scheduled on the CPU according to the algorithm.<br>
        3. The next process P3 arrives at time unit 2. At this time, the execution of process P3 is stopped and the
        process with the least remaining burst time is searched. Since the process P3 has 2 unit of burst time hence it
        will be given priority over others. <br>
        4. The Next Process P4 arrives at time unit 3. At this arrival, the scheduler will stop the execution of P4 and
        check which process is having least burst time among the available processes (P1, P2, P3 and P4). P1 and P2 are
        having the remaining burst time 7 units and 3 units respectively.
        P3 and P4 are having the remaining burst time 1 unit each. Since, both are equal hence the scheduling will be
        done according to their arrival time. P3 arrives earlier than P4 and therefore it will be scheduled again. <br>
        5. The Next Process P5 arrives at time unit 4. Till this time, the Process P3 has completed its execution and it
        is no more in the list. The scheduler will compare the remaining burst time of all the available processes.
        Since the burst time of process P4 is 1 which is least among all hence this will be scheduled. <br>
        6. The Next Process P6 arrives at time unit 5, till this time, the Process P4 has completed its execution. We
        have 4 available processes till now, that are P1 (7), P2 (3), P5 (3) and P6 (2). The Burst time of P6 is the
        least among all hence P6 is scheduled. Since, now, all the processes are available hence the algorithm will now
        work same as SJF. P6 will be executed till its completion and then the process with the least remaining time
        will be scheduled. <br>

      <h3>Note:</h3>
      <p>Once all the processes arrive, No preemption is done and the algorithm will work as SJF.</p>
      </p>

      <h3>Gantt Chart </h3>
      <table border="2px">
        <thead>
          <tr>

            <th>P1</th>
            <th>P2</th>
            <th>P3</th>
            <th>P3</th>
            <th>P4</th>
            <th>P6</th>
            <th>P2</th>
            <th>P5</th>
            <th>P1</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <th>0-1</th>
            <th>1-2</th>
            <th>2-3</th>
            <th>3-4</th>
            <th>4-5</th>
            <th>5-7</th>
            <th>7-10</th>
            <th>10-13</th>
            <th>13-20</th>
          </tr>
        </tbody>

      </table>

      <h3> Final Table </h3>
      <table border="2px">
        <thead>
          <th>Process Name</th>
          <th>Arrival Time</th>
          <th>Burst time</th>
          <th>Completion Time</th>
          <th>Turn Around Time</th>
          <th>Response Time</th>
          <th>Waiting Time</th>

        </thead>
        <tbody>
          <tr>
            <th>P1</th>
            <th>0</th>
            <th>8</th>
            <th>20</th>
            <th>20</th>
            <th>0</th>
            <th>12</th>
          </tr>
          <tr>
            <th>P2</th>
            <th>1</th>
            <th>4</th>
            <th>10</th>
            <th>9</th>
            <th>1</th>
            <th>5</th>
          </tr>
          <tr>
            <th>P3</th>
            <th>2</th>
            <th>2</th>
            <th>4</th>
            <th>2</th>
            <th>2</th>
            <th>0</th>
          </tr>
          <tr>
            <th>P4</th>
            <th>3</th>
            <th>1</th>
            <th>5</th>
            <th>2</th>
            <th>4</th>
            <th>1</th>
          </tr>

          <tr>
            <th>P5</th>
            <th>4</th>
            <th>3</th>
            <th>13</th>
            <th>9</th>
            <th>10</th>
            <th>6</th>
          </tr>

          <tr>
            <th>P6</th>
            <th>5</th>
            <th>2</th>
            <th>7</th>
            <th>2</th>
            <th>5</th>
            <th>0</th>
          </tr>
        </tbody>
      </table>

      <center> <button type="button" class="btn btn-dark btn-outline-primary btn-lg"><a
            href="srtf.html">Calculate</a></button>
      </center>

    </div>


  </div>
  <br>
  <br>
  <br>
  <br>
  <br>

  <div class="fcfs_info a" id="x1">
    <center>
      <h1>FCFS Algorithm</h1>
    </center>
  </div>
  <hr>
  <p>First Come First Serve (FCFS) is an operating system scheduling algorithm that automatically executes queued
    requests and processes in order of their arrival. It is the easiest and simplest CPU scheduling algorithm. In this
    type of algorithm, processes which requests the CPU first get the CPU allocation first. This is managed with a FIFO
    queue. The full form of FCFS is First Come First Serve.
    As the process enters the ready queue, its PCB (Process Control Block) is linked with the tail of the queue and,
    when the CPU becomes free, it should be assigned to the process at the beginning of the queue.
  </p>

  <h3>Characteristics</h3>
  <ul class="fcfs_char">
    <li>It supports non-preemptive and pre-emptive scheduling algorithm.</li>
    <li>Jobs are always executed on a first-come, first-serve basis.</li>
    <li> It is easy to implement and use.</li>
    <li> This method is poor in performance, and the general wait time is quite high.</li>
  </ul>

  <h3>Example</h3>
  <table border="2">
    <th>process</th>
    <th>Arrival Time</th>
    <th>Burst Time</th>

    <tr>
      <td>P1</td>
      <td>2</td>
      <td>6</td>
    </tr>
    <tr>
      <td>P2</td>
      <td>5</td>
      <td>3</td>
    </tr>
    <tr>
      <td>P3</td>
      <td>1</td>
      <td>8</td>
    </tr>
    <tr>
      <td>P4</td>
      <td>0</td>
      <td>3</td>
    </tr>
    <tr>
      <td>P5</td>
      <td>4</td>
      <td>4</td>
    </tr>
  </table>

  <h3>Working</h3>
  <ul class="fcfs_working">
    <li>Step 0) The process begins with P4 which has arrival time 0</li>
    <li>Step 1) At time=1, P3 arrives. P4 is still executing. Hence, P3 is kept in a queue.</li>
    <li>Step 2) At time= 2, P1 arrives which is kept in the queue.</li>
    <li>Step 3) At time=3, P4 process completes its execution.</li>
    <li>Step 4) At time=4, P3, which is first in the queue, starts execution.</li>
    <li>Step 5) At time =5, P2 arrives, and it is kept in a queue.</li>
    <li>Step 6) At time 11, P3 completes its execution.</li>
    <li>Step 7) At time=11, P1 starts execution. It has a burst time of 6. It completes execution at time interval 17
    </li>
    <li>Step 8) At time=17, P5 starts execution. It has a burst time of 4. It completes execution at time=21</li>
    <li>Step 9) At time=21, P2 starts execution. It has a burst time of 2. It completes execution at time interval 23
    </li>
    <li>Step 9) After calculating Completion Time using above steps calculate Turn Around Time, Waiting Time and
      Response Time</li>
  </ul>
  <h3>Gantt Chart</h3>
  <table border="2">
    <th>P4</th>
    <th>P3</th>
    <th>P1</th>
    <th>P5</th>
    <th>P2</th>
    <tr>
      <td>0-3</td>
      <td>3-11</td>
      <td>11-17</td>
      <td>17-21</td>
      <td>21-23</td>
    </tr>
  </table>

  <h3>Final Table</h3>
  <table border="2">
    <th>process</th>
    <th>Arrival Time</th>
    <th>Burst Time</th>
    <th>Complition Time</th>
    <th>Turn Around Time</th>
    <th>Waiting Tme</th>
    <th>Response Time</th>
    <tr>
      <td>P1</td>
      <td>2</td>
      <td>6</td>
      <td>17</td>
      <td>15</td>
      <td>9</td>
      <td>9</td>
    </tr>
    <tr>
      <td>P2</td>
      <td>5</td>
      <td>3</td>
      <td>23</td>
      <td>18</td>
      <td>15</td>
      <td>15</td>
    </tr>
    <tr>
      <td>P3</td>
      <td>1</td>
      <td>8</td>
      <td>11</td>
      <td>10</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <td>P4</td>
      <td>0</td>
      <td>3</td>
      <td>3</td>
      <td>3</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>P5</td>
      <td>4</td>
      <td>4</td>
      <td>21</td>
      <td>17</td>
      <td>13</td>
      <td>13</td>
    </tr>
  </table>

  <h3>Advantages</h3>
  <ul class="fcfs_adv">
    <li>The simplest form of a CPU scheduling algorithm</li>
    <li>Easy to program</li>
    <li>First come first served</li>
  </ul>

  <h3>Disadvantages</h3>
  <ul class="fcfs_adv">
    <li>It is a Non-Preemptive CPU scheduling algorithm, so after the process has been allocated to the CPU, it will
      never release the CPU until it finishes executing.</li>
    <li>The Average Waiting Time is high.</li>
    <li>Short processes that are at the back of the queue have to wait for the long process at the front to finish.</li>
    <li>Not an ideal technique for time-sharing systems.</li>
    <li>Because of its simplicity, FCFS is not very efficient.</li>
  </ul>

  <center> <button type="button" class="btn btn-dark btn-outline-primary btn-lg"><a
    href="fcfs.html">Calculate</a></button>
</center>
  </div>
  <br>
  <br>
  <br>
  <br>
  <br>
  <div class="ljf_info a" id="x3">
    
      <center>
        <h1>Longest Job First (LJF) CPU scheduling algorithm</h1>
      </center>
    </div>
    <hr>

    <div>
      Longest Job First (LJF) is a non-preemptive scheduling algorithm. This algorithm is based upon the burst time of
      the processes. The processes are put into the ready queue based on their burst times i.e., in a descending order
      of the burst times. As the name suggests this algorithm is based upon the fact that the process with the largest
      burst time is processed first. The burst time of only those processes is considered that have arrived in the
      system until that time. Its preemptive version is called Longest Remaining Time First (LRTF) algorithm.
    </div>

    <div>
      <h2>Procudure:</h2>
      <p>
        <span>Step-1:</span><br>
        First, sort the processes in increasing order of their Arrival Time. <br>
        <span>Step-2:</span><br>
        Choose the process having highest Burst Time among all the processes that have arrived till that time. Then
        process it for its burst time. Check if any other process arrives until this process completes execution.<br>
        <span>Step-3:</span><br>
        Repeat the above both steps until all the processes are executed.<br>
        <span>Note:</span><br>
        If two processes have the same burst time then the tie is broken using FCFS i.e., the process that arrived first
        is processed first.<br>
      </p>
    </div>

    <div>
      <h2>Disadvantages</h2>
      <li>This algorithm gives very high average waiting time and average turn-around time for a given set of processes.
      </li>
      <li>This may lead to convoy effect.</li>
      <li>It may happen that a short process may never get executed and the system keeps on executing the longer
        processes.</li>
      <li>It reduces the processing speed and thus reduces the efficiency and utilization of the system.</li>

    </div>

    <div>
      <br>
      <h2>Example</h2>
      <p>Consider the following table of arrival time and burst time for four processes P1, P2, P3 and P4.</p>
      <table border="2px">
        <thead>
          <tr>
            <th>Process Name</th>
            <th>Arrival Time</th>
            <th>Burst time</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <th>P1</th>
            <th>1</th>
            <th>2</th>
          </tr>
          <tr>
            <th>P2</th>
            <th>2</th>
            <th>4</th>
          </tr>
          <tr>
            <th>P3</th>
            <th>3</th>
            <th>6</th>
          </tr>
          <tr>
            <th>P4</th>
            <th>4</th>
            <th>8</th>
          </tr>

        </tbody>
      </table>
      <br>
      <h2>Working</h2>
      <p>
        1. At t = 1, Available Process : P1. So, select P1 and execute 2 ms.<br>
        2. At t = 3 i.e. after P1 gets executed, Available Process : P2, P3. So, select P3 and execute 6 ms (since
        BT(P3)=6 which is higher than BT(P2) = 4)<br>
        3. At t = 9 i.e. after execution of P3, Available Process : P2, P4. So, select P4 and execute 8 ms (since,
        BT(P4) = 8, BT(P2) = 4)<br>
        4. Finally execute the process P2 for 4 ms.<br>
      </p>
      <h2>Note:</h2>
      <p>CPU will be idle for 0 to 1 unit time since there is no process available in the given interval.</p>
      <h3>Gantt chart</h3>
      <table border="2px">
        <thead>
          <tr>
            <th>CPU-Idel</th>
            <th>P1</th>
            <th>P3</th>
            <th>P4</th>
            <th>P2</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <th>0-1</th>
            <th>1-3</th>
            <th>3-9</th>
            <th>9-17</th>
            <th>17-21</th>
          </tr>
        </tbody>

      </table>
      <br>
      <h3>Final Table</h3>
      <table border="2px">
        <thead>
          <th>Process Name</th>
          <th>Arrival Time</th>
          <th>Burst time</th>
          <th>Completion time</th>
          <th>Turn Around Time</th>
          <th>Response Time</th>
          <th>Waiting Time</th>

        </thead>
        <tbody>
          <tr>
            <th>P1</th>
            <th>1</th>
            <th>2</th>
            <th>3</th>
            <th>2</th>
            <th>0</th>
            <th>0</th>
          </tr>
          <tr>
            <th>P2</th>
            <th>2</th>
            <th>4</th>
            <th>21</th>
            <th>19</th>
            <th>15</th>
            <th>15</th>
          </tr>
          <tr>
            <th>P3</th>
            <th>3</th>
            <th>6</th>
            <th>9</th>
            <th>6</th>
            <th>0</th>
            <th>0</th>
          </tr>
          <tr>
            <th>P4</th>
            <th>4</th>
            <th>8</th>
            <th>17</th>
            <th>13</th>
            <th>5</th>
            <th>5</th>
          </tr>
        </tbody>
      </table>


      <center> <button type="button" class="btn btn-dark btn-outline-primary btn-lg"><a
        href="ljf.html">Calculate</a></button>
  </center>
    </div>

  </div>
  <br>
  <br>
  <br>
  <br>
  <br>


  <div class="priority_non_preemptive a" id="x4">
    <center>
      <h1>Priority (Non-Preemptive) Algorithm</h1>
    </center>
    </div>
    <hr>
    <p>
      Priority Scheduling is a method of scheduling processes that is based on priority. In this algorithm, the
      scheduler
      selects the tasks to work as per the priority.
      The processes with higher priority should be carried out first, whereas jobs with equal priorities are carried out
      on FCFS basis. Priority depends upon memory requirements, time requirements, etc.
      In Priority (Non-Preemptive) scheduling method, the CPU has been allocated to a specific process. The process that
      keeps the CPU
      busy, will release the CPU either by switching context or terminating.
    </p>

    <h3>Characteristics</h3>
    <p>
    <ul>
      <li>Priority scheduling is a non-preemptive algorithm and one of the most common scheduling algorithms in batch
        systems.</li>
      <li>Each process is assigned a priority. Process with highest priority is to be executed first and so on.</li>
      <li>Processes with same priority are executed on first come first served basis.</li>
      <li>Priority can be decided based on memory requirements, time requirements or any other resource requirement.
      </li>
    </ul>
    </p>

    <h3>Advantages</h3>
    <ul>
      <li>It is one of the simplest and easiest form of CPU Scheduling Algorithm.</li>
      <li>Process having high priority doesn't have to wait for a long time.</li>
      <li>It is used in the places where time varies eventually along with resources.</li>
    </ul>

    <h3>Disadvantages</h3>
    <ul>
      <li>In this type of algorithm, process having highest priority compared to currently executing process have to
        wait till
        execution ends</li>
      <li>Some low priority processes can be in waiting state for an indefinite time.</li>
      <li>On system crash, low priority processes shall not be scheduled.</li>
      <li>Resource Utilization in parallel is not possible here.</li>
    </ul>

    <h3>Example</h3>

    <table class="que-table" border="2px">
      <tr>
        <th>Process</th>
        <th>Priority</th>
        <th>Arrival Time</th>
        <th>Burst Time</th>
      </tr>
      <tr>
        <td>P1</td>
        <td>0(L)</td>
        <td>0</td>
        <td>4</td>
      </tr>
      <tr>
        <td>P2</td>
        <td>4</td>
        <td>1</td>
        <td>5</td>
      </tr>
      <tr>
        <td>P3</td>
        <td>5</td>
        <td>2</td>
        <td>6</td>
      </tr>
      <tr>
        <td>P4</td>
        <td>10</td>
        <td>3</td>
        <td>7</td>
      </tr>
      <tr>
        <td>P5</td>
        <td>8</td>
        <td>4</td>
        <td>6</td>
      </tr>
      <tr>
        <td>P6</td>
        <td>17(H)</td>
        <td>7</td>
        <td>5</td>
      </tr>
      <tr>
        <td>P7</td>
        <td>9</td>
        <td>8</td>
        <td>4</td>
      </tr>
    </table>

    <h3>Working</h3>

    <ul>
      <li>Step 0) Since at T = 0 only P1 has arrived, it will get executed first despite having the lowest priority</li>
      <li>Step 1) At T = 4 P1 has executed completely and the processes P2, P3, P4 and P5 have arrived</li>
      <li>Step 2) Out of processes P2, P3, P4 and P5, P4 has the highest priority hence it will get executed at T = 4
      </li>
      <li>Step 3) At T = 11 P4 has executed completely and the processes P2, P3, P5, P6 and P7 are in the waiting queue
      </li>
      <li>Step 4) Out of processes P2, P3, P5, P6 and P7, P6 has the highest priority hence it will get executed at T =
        11</li>
      <li>Step 5) At T = 16 P6 has executed completely and the processes P2, P3, P5 and P7 are in the waiting queue</li>
      <li>Step 6) Out of processes P2, P3, P5 and P7, P7 has the highest priority hence it will get executed at T = 16
      </li>
      <li>Step 7) At T = 20 P7 has executed completely and the processes P2, P3 and P5 are in the waiting queue</li>
      <li>Step 8) Out of processes P2, P3 and P5, P5 has the highest priority hence it will get executed at T = 20</li>
      <li>Step 9) At T = 26 P5 has executed completely and the processes P2 and P3 are in the waiting queue</li>
      <li>Step 10) Out of processes P2 and P3, P3 has the highest priority hence it will get executed at T = 26</li>
      <li>Step 11) At T = 32 P3 has executed completely and the process P2 is in the waiting queue</li>
      <li>Step 12) Finally P2 will get executed at T = 32 and will get completely executed by T = 37</li>
    </ul>

    <h3>Gantt Chart</h3>

    <table border="2">
      <th>P1</th>
      <th>P4</th>
      <th>P6</th>
      <th>P7</th>
      <th>P5</th>
      <th>P3</th>
      <th>P2</th>
      <tr>
        <td>0 - 4</td>
        <td>4 - 11</td>
        <td>11 - 16</td>
        <td>16 - 20</td>
        <td>20 - 26</td>
        <td>26 - 32</td>
        <td>32 - 37</td>
      </tr>
    </table>

    <h3>Final Table</h3>

    <table border="2px">
      <tr>
        <th>Process</th>
        <th>Priority</th>
        <th>Arrival Time</th>
        <th>Burst Time</th>
        <th>Completion Time</th>
        <th>Turn Around Time</th>
        <th>Waiting Time</th>
        <th>Response Time</th>
      </tr>

      <tr>
        <td>P1</td>
        <td>0(L)</td>
        <td>0</td>
        <td>4</td>
        <td>4</td>
        <td>4</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr>
        <td>P2</td>
        <td>4</td>
        <td>1</td>
        <td>5</td>
        <td>37</td>
        <td>36</td>
        <td>31</td>
        <td>31</td>
      </tr>
      <tr>
        <td>P3</td>
        <td>5</td>
        <td>2</td>
        <td>6</td>
        <td>32</td>
        <td>30</td>
        <td>24</td>
        <td>24</td>
      </tr>
      <tr>
        <td>P4</td>
        <td>10</td>
        <td>3</td>
        <td>7</td>
        <td>11</td>
        <td>8</td>
        <td>1</td>
        <td>1</td>
      </tr>
      <tr>
        <td>P5</td>
        <td>8</td>
        <td>4</td>
        <td>6</td>
        <td>26</td>
        <td>22</td>
        <td>16</td>
        <td>16</td>
      </tr>
      <tr>
        <td>P6</td>
        <td>17(H)</td>
        <td>7</td>
        <td>5</td>
        <td>16</td>
        <td>9</td>
        <td>4</td>
        <td>4</td>
      </tr>
      <tr>
        <td>P7</td>
        <td>9</td>
        <td>8</td>
        <td>4</td>
        <td>20</td>
        <td>12</td>
        <td>8</td>
        <td>8</td>
      </tr>
    </table>

    <center> <button type="button" class="btn btn-dark btn-outline-primary btn-lg"><a
      href="non-preemptive.html">Calculate</a></button>
</center>
  </div>
  <br>
  <br>
  <br>
  <br>
  <br>
  <div class="priority_preemptive a" id="x5">
    <center>
      <h1>Priority (Preemptive) Algorithm</h1>
    </center>
    </div>
    <hr>
    <p>
      This is the Preemptive version of Priority scheduling. In this type of scheduling the processes which are present
      in ready queue are compared and the process with highest priority is selected for execution.The difference between
      non-Preemptive Priority Scheduling and Preemptive Priority Scheduling is that in non-preemptive if a process comes
      inside CPU then it can't be preempted and it will execute completely. However, in case of Preemptive Priority
      Scheduling a process which is executing inside CPU can be preempted if a higher priority process comes in the
      ready queue.
    </p>

    <h3>Characteristics</h3>
    <p>
    <ul>
      <li>Priority scheduling is one of the most common scheduling algorithms in batch systems.</li>
      <li>Each process is assigned a priority. Process with highest priority is to be executed first and so on.</li>
      <li>Processes with same priority are executed on first come first served basis.</li>
      <li>Priority can be decided based on memory requirements, time requirements or any other resource requirement.
      </li>
    </ul>
    </p>

    <h3>Advantages</h3>
    <ul>
      <li>It is one of the simplest and easiest form of CPU Scheduling Algorithm.</li>
      <li>Process having high priority doesn't have to wait for a long time.</li>
      <li>It is used in the places where time varies eventually along with resources.</li>
    </ul>

    <h3>Disadvantages</h3>
    <ul>
      <li>In this type of algorithm, process having highest priority compared to currently executing process have to
        wait till
        execution ends</li>
      <li>Some low priority processes can be in waiting state for an indefinite time.</li>
      <li>On system crash, low priority processes shall not be scheduled.</li>
      <li>Resource Utilization in parallel is not possible here.</li>
    </ul>

    <h3>Example</h3>

    <table class="que-table" border="2px">
      <tr>
        <th>Process</th>
        <th>Priority</th>
        <th>Arrival Time</th>
        <th>Burst Time</th>
      </tr>
      <tr>
        <td>P1</td>
        <td>10(L)</td>
        <td>0</td>
        <td>5</td>
      </tr>
      <tr>
        <td>P2</td>
        <td>20</td>
        <td>1</td>
        <td>4</td>
      </tr>
      <tr>
        <td>P3</td>
        <td>30</td>
        <td>2</td>
        <td>2</td>
      </tr>
      <tr>
        <td>P4</td>
        <td>40(H)</td>
        <td>4</td>
        <td>10</td>
      </tr>
    </table>

    <h3>Working</h3>

    <ul>
      <li>Since at T = 0 only P1 has arrived, it will get executed first for 1 time unit despite having the lowest
        priority</li>
      <li>At T = 1 P2 has arrived and it has higher priority than P1,So P2 will go in the running queue and P1 will be
        premepted to ready queue.</li>
      <li>At T = 2 P3 has arrived and it has higher priority than P2,So P3 will go in the running queue and P2 will be
        premepted to ready queue.</li>
      <li>At T = 3 no new process will come, so P3 will run for another time unit and it will be terminated</li>
      <li>At T=4 P4 will come in ready queue and it has highest priority and it will run for 1 time unit and get
        terminated. </li>
      <li>At T =5 all processes are arrived, so P2 will come in running queue from ready queue and it will run for 3
        time unit and get terminated.</li>
      <li>At T=8 only P1 process is there in ready queue and it will run for 4 time unit and get terminated.</li>
      <li>At T=12 all process will be terminated.</li>
    </ul>

    <h3>Gantt Chart</h3>

    <table border="2">
      <th>P1</th>
      <th>P2</th>
      <th>P3</th>
      <th>P4</th>
      <th>P2</th>
      <th>P1</th>
      <tr>
        <td>0 - 1</td>
        <td>1 - 2</td>
        <td>2 - 4</td>
        <td>4 - 5</td>
        <td>5 - 8</td>
        <td>8 - 12</td>
      </tr>
    </table>

    <h3>Final Table</h3>

    <table border="2px">
      <tr>
        <th>Process</th>
        <th>Priority</th>
        <th>Arrival Time</th>
        <th>Burst Time</th>
        <th>Completion Time</th>
        <th>Turn Around Time</th>
        <th>Waiting Time</th>
        <th>Response Time</th>
      </tr>

      <tr>
        <td>P1</td>
        <td>10(L)</td>
        <td>0</td>
        <td>5</td>
        <td>12</td>
        <td>12</td>
        <td>7</td>
        <td>0</td>
      </tr>
      <tr>
        <td>P2</td>
        <td>20</td>
        <td>1</td>
        <td>4</td>
        <td>8</td>
        <td>7</td>
        <td>3</td>
        <td>0</td>

      </tr>
      <tr>
        <td>P3</td>
        <td>30</td>
        <td>2</td>
        <td>2</td>
        <td>4</td>
        <td>2</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr>
        <td>P4</td>
        <td>40(H)</td>
        <td>4</td>
        <td>1</td>
        <td>5</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
      </tr>
    </table>

    <center> <button type="button" class="btn btn-dark btn-outline-primary btn-lg"><a
      href="preemptive.html">Calculate</a></button>
</center>
<br>
<br>
<br>
<br>
<br>
  </div>
  <div class="RR_info a" id="x6">
    <center>
      <h1>RR Algorithm</h1>
    </center>
    </div>
    <hr>
    <p>Round-robin Scheduling
      Round-robin scheduling allocates each task an equal share of the CPU time. In its simplest form, tasks are in a
      circular queue and when a task's allocated CPU time expires, the task is put to the end of the queue and the new
      task is taken from the front of the queue. Round-robin scheduling is not very satisfactory in many real-time
      applications where each task can have varying amounts of CPU requirements depending upon the complexity of
      processing required. One variation of the pure round-robin scheduling is to provide priority-based scheduling,
      where tasks with the same priority levels receive equal amounts of CPU time. It is also possible to allocate
      different maximum CPU times to each task. </p>

    <h3>Characteristics</h3>
    <ul class="RR_char">
      <li>Round Robin is the preemptive process scheduling algorithm.</li>
      <li>Each process is provided a fix time to execute, it is called a quantum.</li>
      <li>Once a process is executed for a given time period, it is preempted and other process executes for a given
        time period.</li>
      <li> Context switching is used to save states of preempted processes.</li>
    </ul>
    <h3>Advantages</h3>
    <ul class="RR_adv">
      <li>All the jobs get a fair allocation of CPU.</li>
      <li>It deals with all process without any priority</li>
      <li>This scheduling method does not depend upon burst time. That's why it is easily implementable on the system.
      </li>
      <li>Once a process is executed for a specific set of the period, the process is preempted, and another process
        executes for that given time period.</li>
      <li>It gives the best performance in terms of average response time.</li>
    </ul>

    <h3>Disadvantages</h3>
    <ul class="RR_disadv">
      <li>If slicing time of OS is low, the processor output will be reduced.</li>
      <li>This method spends more time on context switching</li>
      <li>Its performance heavily depends on time quantum.</li>
      <li>Decreases comprehension</li>
      <li>Finding a correct time quantum is a quite difficult task in this system.</li>
    </ul>
    <h3>Example</h3><br>
    <h5>Time quantum: 4</h5>
    <table border="2">
      <th>process</th>
      <th>Arrival Time</th>
      <th>Burst Time</th>

      <tr>
        <td>P1</td>
        <td>0</td>
        <td>5</td>
      </tr>
      <tr>
        <td>P2</td>
        <td>1</td>
        <td>6</td>
      </tr>
      <tr>
        <td>P3</td>
        <td>2</td>
        <td>3</td>
      </tr>
      <tr>
        <td>P4</td>
        <td>3</td>
        <td>1</td>
      </tr>
      <tr>
        <td>P5</td>
        <td>4</td>
        <td>5</td>
      </tr>
      <tr>
        <td>P6</td>
        <td>6</td>
        <td>4</td>
      </tr>
    </table>

    <h3>Working</h3>
    <ol class="RR_working">
      <li>In round robin scheduling algorithm every process is picked up and is allowed to execute for the period of
        time quantum.After which the process is preempted and again put back in the ready queue after which another
        process is picked up and the same scenario is repeated over and over until all the processes are completed.</li>
      <li>Once a process is picked up from the ready queue for its execution a precondition is checked weather the
        process burst time is greater than the time quantum or not.</li>
      <li>If the process burst time is greater than the time quantum the process is allowed to execute for the period of
        time quantam. After which it is again puts back into the ready queue. (In such case the burst time is deduce by
        the given time quantum and the process is again put back into the ready queue for its execution for the
        remaining period of time.)</li>
      <li>The above scenario is repeated until the process is completed and goes to the termination state.</li>
      <li>If the process burst time is less than the time quantum the process is allowed to execute for its burst time
        and then the process is terminated.</li>
    </ol>
    <h3>Gantt Chart</h3>
    <table border="2">
      <th>P1</th>
      <th>P2</th>
      <th>P3</th>
      <th>P4</th>
      <th>P5</th>
      <th>P1</th>
      <th>P6</th>
      <th>P2</th>
      <th>P5</th>
      <tr>
        <td>0-4</td>
        <td>4-8</td>
        <td>8-11</td>
        <td>11-12</td>
        <td>12-16</td>
        <td>16-17</td>
        <td>17-21</td>
        <td>21-23</td>
        <td>23-24</td>
      </tr>
    </table>

    <h3>Final Table</h3>
    <table border="2">
      <th>Process</th>
      <th>Arrival Time</th>
      <th>Burst Time</th>
      <th>Complition Time</th>
      <th>Turn Around Time</th>
      <th>Waiting Tme</th>
      <th>Response Time</th>
      <tr>
        <td>P1</td>
        <td>0</td>
        <td>5</td>
        <td>17</td>
        <td>17</td>
        <td>12</td>
        <td>0</td>
      </tr>
      <tr>
        <td>P2</td>
        <td>1</td>
        <td>6</td>
        <td>23</td>
        <td>22</td>
        <td>16</td>
        <td>3</td>
      </tr>
      <tr>
        <td>P3</td>
        <td>2</td>
        <td>3</td>
        <td>11</td>
        <td>9</td>
        <td>6</td>
        <td>6</td>
      </tr>
      <tr>
        <td>P4</td>
        <td>3</td>
        <td>1</td>
        <td>12</td>
        <td>9</td>
        <td>8</td>
        <td>8</td>
      </tr>
      <tr>
        <td>P5</td>
        <td>4</td>
        <td>5</td>
        <td>24</td>
        <td>20</td>
        <td>15</td>
        <td>8</td>
      </tr>
      <tr>
        <td>P6</td>
        <td>6</td>
        <td>4</td>
        <td>21</td>
        <td>15</td>
        <td>11</td>
        <td>11</td>
      </tr>
    </table>


    <center> <button type="button" class="btn btn-dark btn-outline-primary btn-lg"><a
      href="rr.html">Calculate</a></button>
</center>
<br>
<br>
<br>
<br>
<br>
  </div>
  <div class="sjf a" id="x2">
    <center>
      <h1>Shortest Job First Algorithm</h1>
    </center>
    </div>
    <hr>
    <p>
      Shortest Job First (SJF) is an algorithm in which the process having the smallest execution time is chosen for the
      next execution. This scheduling method can be preemptive or non-preemptive. It significantly reduces the average
      waiting time for other processes awaiting execution. The full form of SJF is Shortest Job First.
    </p>

    <h3>Characteristics</h3>
    <p>
    <ul>
      <li>It is associated with each job as a unit of time to complete.</li>
      <li>This algorithm method is helpful for batch-type processing, where waiting for jobs to complete is not
        critical.</li>
      <li>It can improve process throughput by making sure that shorter jobs are executed first, hence possibly have a
        short turnaround time.</li>
      <li>It improves job output by offering shorter jobs, which should be executed first, which mostly have a shorter
        turnaround time.</li>
    </ul>
    </p>

    <h3>Advantages</h3>
    <ul>
      <li>It is optimal for minimizing the queuing time.</li>
      <li>It is easy to implement in batch systems as we know in this we know the required CPU time.</li>
      <li>It’s average waiting time, or AWT is minimum amongst all the scheduling algorithms.</li>
    </ul>

    <h3>Disadvantages</h3>
    <ul>
      <li>It is challenging to implement in the interactive system as we don’t know the required CPU time here.</li>
      <li>Usually, run times are not known in this scheduling.</li>
      <li>If the arrival time of the processes is different, i.e. different processes arrive at different time for the
        execution, then sometimes, the process which has shortest burst time will have to wait so that the current
        process can finish its performance. The reason behind this is its non-preemptive mode as in this the current
        process is not halted in between on arrival of shortest burst process.This brings the starvation problem which
        is solved by the process of ageing.</li>
    </ul>

    <h3>Example</h3>

    <table class="que-table" border="2px">
      <tr>
        <th>Process</th>
        <th>Arrival Time</th>
        <th>Burst Time</th>
      </tr>
      <tr>
        <td>P1</td>
        <td>2</td>
        <td>6</td>
      </tr>
      <tr>
        <td>P2</td>
        <td>5</td>
        <td>2</td>
      </tr>
      <tr>
        <td>P3</td>
        <td>1</td>
        <td>8</td>
      </tr>
      <tr>
        <td>P4</td>
        <td>0</td>
        <td>3</td>
      </tr>
      <tr>
        <td>P5</td>
        <td>4</td>
        <td>4</td>
      </tr>

    </table>

    <h3>Working</h3>

    <ul>
      <li>Step 0) At time=0, P4 arrives and starts execution.</li>
      <li>Step 1) At time= 1, Process P3 arrives. But, P4 still needs 2 execution units to complete. It will continue
        execution.</li>
      <li>Step 2) At time =2, process P1 arrives and is added to the waiting queue. P4 will continue execution.</li>
      <li>Step 3) At time = 3, process P4 will finish its execution. The burst time of P3 and P1 is compared. Process P1
        is executed because its burst time is less compared to P3.</li>
      <li>Step 4) At time = 4, process P5 arrives and is added to the waiting queue. P1 will continue execution.</li>
      <li>Step 5) At time = 5, process P2 arrives and is added to the waiting queue. P1 will continue execution.</li>
      <li>Step 6) At time = 9, process P1 will finish its execution. The burst time of P3, P5, and P2 is compared.
        Process P2 is executed because its burst time is the lowest.</li>
      <li>Step 7) At time=10, P2 is executing and P3 and P5 are in the waiting queue.</li>
      <li>Step 8) At time = 11, process P2 will finish its execution. The burst time of P3 and P5 is compared. Process
        P5 is executed because its burst time is lower.</li>
      <li>Step 9) At time = 15, process P5 will finish its execution.</li>
      <li>Step 10) At time = 23, process P3 will finish its execution.</li>
    </ul>

    <h3>Gantt Chart</h3>

    <table border="2">
      <th>P4</th>
      <th>P1</th>
      <th>P2</th>
      <th>P5</th>
      <th>P3</th>
      <tr>
        <td>0 - 3</td>
        <td>3 - 9</td>
        <td>9- 11</td>
        <td>11 - 15</td>
        <td>15 - 23</td>
      </tr>
    </table>

    <h3>Final Table</h3>

    <table border="2px">
      <tr>
        <th>Process</th>
        <th>Arrival Time</th>
        <th>Burst Time</th>
        <th>Completion Time</th>
        <th>Turn Around Time</th>
        <th>Waiting Time</th>
        <th>Response Time</th>
      </tr>

      <tr>
        <td>P1</td>
        <td>2</td>
        <td>6</td>
        <td>9</td>
        <td>7</td>
        <td>1</td>
        <td>1</td>
      </tr>
      <tr>
        <td>P2</td>
        <td>5</td>
        <td>2</td>
        <td>11</td>
        <td>6</td>
        <td>4</td>
        <td>4</td>
      </tr>
      <tr>
        <td>P3</td>
        <td>1</td>
        <td>8</td>
        <td>23</td>
        <td>22</td>
        <td>14</td>
        <td>14</td>
      </tr>
      <tr>
        <td>P4</td>
        <td>0</td>
        <td>3</td>
        <td>3</td>
        <td>3</td>
        <td>0</td>
        <td>0</td>
      </tr>
      <tr>
        <td>P5</td>
        <td>4</td>
        <td>4</td>
        <td>15</td>
        <td>11</td>
        <td>7</td>
        <td>7</td>
      </tr>
    </table>

    <center> <button type="button" class="btn btn-dark btn-outline-primary btn-lg"><a
      href="sjf.html">Calculate</a></button>
</center>
  </div>
  <!-- Optional JavaScript; choose one of the two! -->

  <!-- Option 1: Bootstrap Bundle with Popper -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
    crossorigin="anonymous"></script>

  <!-- Option 2: Separate Popper and Bootstrap JS -->
  <!--
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js" integrity="sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13" crossorigin="anonymous"></script>
    -->
</body>

</html>